/* autogenerated by Processing revision 1292 on 2023-10-24 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.io.*;
import java.io.*;
import java.util.*;
import java.util.*;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ImageEdit_2 extends PApplet {




float NANO_TO_MILLI = 0.000001f;
PImage currentImage, originalImage;
PVector offset, scale, dscale, mousePos, pmousePos;
PVector defSize, windowScale;
int currentColor, bg;
boolean pmousePressed;
int textSize = 22;
UIGrid grid;
boolean drawWireFrames = false;
Slider graphSlider;
//invert, blur, flip x axis, flip y axis
List<Boolean> filtersOn;
List<String> filters;
List<Integer> mults, offs;
List<Boolean> hasSlider;
List<Float> defSliderVal;
PImage s;
boolean pixelSelected;
int selectedIndex;
List<PImage> images;
int imgIndex = 0;
boolean shft = false;
ColorGraph cg = new ColorGraph(new PVector(256 * 1.2f, 100 * 1.2f));
UIGrid buttonGrid;
//-- settings data from settings.txt
List<String> settingsData;

public void setup() {
  //-- settings data from settings.txt
  settingsData = readFile("data\\settings.txt");
  //-- settings
  windowScale = new PVector(1, 1);
  defSize = new PVector(1920, 1080);
  /* size commented out by preprocessor */;
  /* pixelDensity commented out by preprocessor */;
  /* noSmooth commented out by preprocessor */;
  frameRate(90);
  surface.setResizable(true);
  surface.setIcon(loadImage("data\\images\\i2.png"));
  surface.setTitle("PFJ Image Editor");
  textFont(createFont("Ebrima", textSize));
  
  //-- vars
  loadImages();
  offset = new PVector();
  scale = new PVector(1, 1);
  dscale = new PVector(1, 1);
  mousePos = new PVector(mouseX, mouseY);
  pmousePos = new PVector(mouseX, mouseY);
  bg = color(220, 220, 220);
  
  //default values to start on program start up
  offset = new PVector(100, 100);
  scale = new PVector(2, 2);
  dscale = new PVector(2.5f, 2.5f);
  
  graphSlider = new Slider(new PVector(cg.pos.x, cg.pos.y + cg.size.y + 4), new PVector(cg.size.x,20), new PVector(10, 20000));
  graphSlider.set(9500);
  
  filters = new ArrayList<>();
  offs = new ArrayList<>();
  mults = new ArrayList<>();
  hasSlider = new ArrayList<>();
  defSliderVal = new ArrayList<>();
  List<String> data = readFile("data\\filters.txt");
    
  for (String s : data) {
    String[] a = s.split(",");
    filters.add(a[0]);
    offs.add(Integer.parseInt(a[1]));
    mults.add(Integer.parseInt(a[2]));
    hasSlider.add(Boolean.parseBoolean(a[3]));
    //println(hasSlider.get(hasSlider.size() - 1));
    defSliderVal.add((Boolean.parseBoolean(a[3])) ? Float.parseFloat(a[4]) : -1);
  }
   
  filtersOn = new ArrayList<>();
  
  for (int i = 0; i < filters.size(); i++) {
    filtersOn.add(false);
  }
  
  //set buffer
  setBuffer(images.get(0));

  //-- ui
  //checkboxes & slider
  grid = new UIGrid(new PVector(1570, 390), new PVector(420, 530), 16, 2);
  PVector cbSize = new PVector(130, 17);
  for (int i = 0; i < filters.size(); i++) {
    Checkbox cb = new Checkbox(cbSize, filters.get(i));
    grid.add(cb, i, 0, true);
  }
  
  //sliders
  PVector sliderSize = new PVector(100, 24);
  PVector sliderRange = new PVector(0, 1);
  for (int i = 0; i < filters.size(); i++) {
    if (!hasSlider.get(i)) continue;
    grid.add(new Slider(grid.posAt(i,1), sliderSize, sliderRange), i, 1, true);
    ((Slider) grid.getElement(i, 1)).set(defSliderVal.get(i));
  }
  
  //button grid
  buttonGrid = new UIGrid(new PVector(1570, 915), new PVector(320, 130), 3, 3);
  
  PVector buttonSize = new PVector(102, 40);
  int buttonColor = brighten(bg, 12);
  int c = 0;
  for (int i = 0; i < buttonGrid.rows; i++) {
    for (int j = 0; j < buttonGrid.cols; j++) {
      c++;
      buttonGrid.add(new Button(buttonGrid.posAt(i, j), buttonSize, buttonColor, "Preset " + c), i, j, false);
    }
  }
}

public void loadImages() {
  List<String> imageDirs = new ArrayList<>();
  try {
    imageDirs = readFile("data\\imgDirs.txt");  
  } catch (Exception ignored) {
    println("Error loading images");
  }
  
  images = new ArrayList<>();
  
  for (String dir : imageDirs) {
    images.add(loadImage(dir));
  }
  
  int imageSize = Integer.parseInt(settingsData.get(0).split(",")[1]);
  
  for (int i = 0; i < images.size(); i++) {
    images.get(i).resize(Math.min(imageSize, images.get(i).width), 0);
  }
  
  originalImage = images.get(imgIndex);
  currentImage = originalImage.copy();
}

public void draw() {
  pre();
  mouseMovement();
  updateScale();
  
  //update
  graphSlider.update();
  buttonGrid.update();
  grid.update();
  updateEditor();
  
  //update presets of buttonGrid
  for (int i = 1; i <= buttonGrid.elements.size(); i++) {
    Button button = (Button) buttonGrid.elements.get(i - 1);
    if (button.clicked) {
      load("data\\presets\\preset" + i + ".txt");
    }
  }
  
  //scale based on window size
  windowScale =  new PVector(width / defSize.x, height / defSize.y);
  scale(windowScale.x, windowScale.y);
  
  //draw bg
  background(230);
  
  //draw image number label in top left
  textSize(26);
  fill(140);
  noStroke();
  textAlign(LEFT, TOP);
  text("<- Image " + " " + (imgIndex + 1) + " ->", 5, 5);
  textAlign(LEFT, BOTTOM);

  //draw edited image
  pushMatrix();
  scale(scale.x, scale.y);
  translate(offset.x, offset.y);
  image(buffer, 0, 0);
  popMatrix();
  
  PVector m = mousePos.copy().mult(1 / scale.x).sub(offset);
  currentColor = getPixel(m);
  


    //debug
  //fill(255);
  //text(red(currentColor) + "," + green(currentColor) + "," + blue(currentColor), 0, 20);
  //text(m.toString(), 0, 40);
  //text(frameRate, 0, 60);
  //text("mp: " + mousePos.toString(), 0, 80);
  //text("jobs: " + jobs.toString(), 0, 100);
  //text("current index: " + currentIndex + "/" + (buffer.width * buffer.height), 0, 120);
  //fill(currentColor);
  //strokeWeight(2);
  //stroke(255);
  //rect(10, 50, 10, 10);
  //text(width + ", " + height, 0, 80);
  
  //apply filters
  updateFilters();

  //draw side panel
  fill(bg);
  strokeWeight(1);
  stroke(40);
  rect(defSize.x * 0.8f, 0, defSize.x * 0.2f, defSize.y);
  //color square
  strokeWeight(1);
  stroke(80);
  fill(currentColor);
  rectMode(CENTER);
  rect(defSize.x * 0.9f, 170, 240, 240);
  rectMode(CORNER);
  noStroke();
  //rgb of color
  textAlign(CENTER);
  textSize(40);
  //textStroke("[" + red(currentColor) + "," + green(currentColor) + "," + blue(currentColor) + "]", defSize.x * 0.9, 360, 1);
  text("[" + red(currentColor) + "," + green(currentColor) + "," + blue(currentColor) + "]", defSize.x * 0.9f, 350);
  textSize(textSize);
  
  //draw ui
  buttonGrid.draw();
  grid.draw();
  highlightCurrentPixel();
  
  //color graph
  cg.update(buffer);
  cg.draw();
  
  //graph slider
  graphSlider.draw();
  
  post();
}

public void pre() {
  mousePos = new PVector(mouseX / windowScale.x, mouseY / windowScale.y);
  pmousePos = new PVector(pmouseX / windowScale.x, pmouseY / windowScale.y);
}

public void updateFilters() {
  List<UIElement> updates = new ArrayList<>();
  
  for (int i = 0; i < grid.elements.size(); i++) {
    UIElement e = grid.elements.get(i);
    if (e.updated) updates.add(e);
  }
  
  if (updates.size() == 0) {
    return;
  } else {
    for (UIElement e : updates) {
      try {
        Checkbox c = (Checkbox) e;
        if (c.checked) filtersOn.set(filters.indexOf(c.text), true);
        if (!c.checked) filtersOn.set(filters.indexOf(c.text), false);
      } catch (Exception ignored) {
        continue;
      }
    }
  }
  
  applyFilters();
}

public void applyFilters() {
  //reset current image then re-add new, updated filters
  currentImage = originalImage.copy();
  setBuffer(originalImage);
  jobs = new ArrayList<>();
  params = new ArrayList<>();
  currentIndex = 0;
  
  for (int i = 0; i < filtersOn.size(); i++) {
    if (!filtersOn.get(i)) continue;
    if (hasSlider.get(i)) {
      request(filters.get(i), offs.get(i) + (mults.get(i) * ((Slider) grid.getElement(i, 1)).currVal));
    } else {
      request(filters.get(i));
    }
  }
}

public void post() {
  pmousePressed = mousePressed;
}

public void updateScale() {
  PVector pm = screenToWorld(mousePos, offset, scale);
  scale = new PVector(scale.x + ((dscale.x - scale.x) * 0.3f), scale.y + ((dscale.y - scale.y) * 0.3f));
  PVector nm = screenToWorld(mousePos, offset, scale);
  offset.add(nm.sub(pm));
}

public void mouseWheel(MouseEvent e) {
  if (e.getCount() < 0) dscale.mult(1.15f);
  if (e.getCount() > 0) dscale.mult(0.85f);
}

public void mouseMovement() {
  if (mousePressed) {
    if (shft) {
      pixelSelected = true;
      selectedIndex = getPixelIndex(mousePos.copy().mult(1 / scale.x).sub(offset));   
    }
    if (!shft && mouseX < width * 0.8f && !graphSlider.dragging) {
      pixelSelected = false;
      PVector delta = new PVector(mousePos.x - pmousePos.x, mousePos.y - pmousePos.y);
      offset.add(delta.mult(1 / scale.x));
    }
  }
}

public void keyPressed() {
  if (keyCode == SHIFT) shft = true;
  if (key == 'r') {
    //offset = new PVector();
    //dscale = new PVector(1, 1);
    //scale = new PVector(1, 1);
    
    for (int i = 0; i < grid.elements.size(); i++) {
      try {
        Checkbox c = (Checkbox) grid.elements.get(i);   
        c.checked = false;
        c.updated = true;
      } catch (Exception ignored) {}
      try {
        Slider s = (Slider) grid.elements.get(i);   
        s.currPos = s.pos.copy();
      } catch (Exception ignored) {}
    }
    currentImage = originalImage;
    updateFilters();
  }
    
  if (keyCode == RIGHT) {
    imgIndex = (imgIndex + 1) % images.size();
    originalImage = images.get(imgIndex);
    currentImage = originalImage.copy();
    applyFilters();
  }
  
  if (keyCode == LEFT) {
    imgIndex = (imgIndex - 1) % images.size();
    if (imgIndex < 0) imgIndex = images.size() - 1;
    originalImage = images.get(imgIndex);
    currentImage = originalImage.copy();
    applyFilters();
  }
  
  //-- for saving ui values for the presets lol
 
  //for (int i = 1; i < 10; i++) {
  //  String s = String.valueOf(i);
  //  char ch = s.charAt(0);
  //  if (key == ch) {
  //    println('k');
  //    try {
  //      BufferedWriter bw = new BufferedWriter(new FileWriter("presets\\preset" + i + ".txt"));
        
  //      for (UIElement e : grid.elements) {
  //        try {
  //          Slider slider = (Slider) e;
  //          bw.write(String.valueOf(slider.getProp()));
  //          bw.newLine();
  //        } catch (Exception ignored) {}
  //        try {
  //          Checkbox checkbox = (Checkbox) e;
  //          bw.write(String.valueOf(checkbox.checked));
  //          bw.newLine();
  //        } catch (Exception ignored) {}
  //      }
        
  //      bw.close();
  //    } catch(Exception e) {
  //      e.printStackTrace();
  //    }    
  //  } else {
  //    println(key + "   " + String.valueOf(i) + "     " + ch);
  //  }
  //}
}

public void keyReleased() {
  if (keyCode == SHIFT) shft = false;
}

public void highlightCurrentPixel() {
   //rect((int) ((mousePos.x + ((offset.x % 1) * scale.x)) / scale.x) * scale.x, (int) (mousePos.y / scale.y) * scale.y + ((offset.y % 1) * scale.y), scale.x, scale.y);
   //println(offset.x % 1);
}

public int getPixel(PVector pos) {
  int c;
  int index = 0;
  currentImage.loadPixels();
  try {
    index = (int) (((int) (pos.y) * buffer.width) + (int) (pos.x));
    c = buffer.pixels[index];
  } catch (Exception ignored) {
    return buffer.pixels[0];
  }
  
  if (pixelSelected) {
    c = buffer.pixels[selectedIndex];
  }
  
  return c;
}

public int getPixelIndex(PVector pos) {
  int index = 0;
  try {
    index = (int) (((int) (pos.y) * buffer.width) + (int) (pos.x));
  } catch (Exception ignored) {}
  
  return index;
}

public void load(String dir) {
  List<String> fileList = readFile(dir);
  for (int i = 0; i < fileList.size(); i++) {
    try {
      Checkbox checkbox = (Checkbox) grid.elements.get(i);
      checkbox.checked = Boolean.parseBoolean(fileList.get(i));
      checkbox.updated = true;
    } catch (Exception ignored) {}
    try {
      Slider slider = (Slider) grid.elements.get(i);
      slider.set(Float.parseFloat(fileList.get(i)));
    } catch (Exception ignored) {}
  }
}
class Button extends UIElement {
  int bgColor;
  boolean hover, clicked;
  String text;
  
  public Button(PVector pos, PVector size, int bgColor, String text) {
    super(pos, size, loadImage("data\\ui\\cb_2.png"));
    this.bgColor = bgColor;
    this.text = text;
  }
  
  @Override
  public void update() {
    hover = pointInsideRect(mousePos, pos, size);
    clicked = hover && mousePressed && !pmousePressed;
  }
  
  @Override
  public void draw() {
    fill((mousePressed && hover) ? darken(bgColor) : bgColor);
    strokeWeight(1);
    stroke(150);
    rect(pos.x, pos.y, size.x, size.y);
    textAlign(CENTER, CENTER);
    noStroke();
    fill(100);
    textSize(size.y / 2);
    text(text, pos.x + size.x * 0.5f, pos.y + size.y * 0.45f);
    textAlign(LEFT, BOTTOM);
  }
}
class Checkbox extends UIElement {
  String text;
  boolean checked, centered;
  PImage currSprite;
  
  public Checkbox(PVector size, String text) {
    super(new PVector(), size, loadImage("data\\ui\\cb_2.png"), loadImage("data\\ui\\cb_1.png"), loadImage("data\\ui\\cb_3.png"), loadImage("data\\ui\\cb_4.png"));
    
    for (PImage i : sprites) {
      i.resize(0, (int) size.y);
    }
    
    this.centered = false;
    this.text = text;
  }
  
  @Override
  public void update() {
    if (updated) updated = false;
    if (pointInsideRect(mousePos, pos, size)) {
      if (!pmousePressed && mousePressed) {
        checked = !checked;
        updated = true;
      }
      currSprite = sprites.get(2);
      if (checked) currSprite = sprites.get(3);
    } else {
      currSprite = sprites.get(1);
      if (checked) currSprite = sprites.get(0);
    }
  }
  
  @Override
  public void draw() {
    super.draw();
    
    image(currSprite, pos.x, pos.y);
    fill(80);
    textAlign(LEFT, CENTER);
    textSize(size.y * 1.2f);
    text(text, pos.x + size.y + (textSize / 2), pos.y + (size.y / 4));
    textAlign(BASELINE);  
  }
}
class ColorGraph {
  int[] reds, greens, blues;
  int max = 0;
  PVector pos, size;
  
  ColorGraph(PVector size) {
    this.size = size;
    this.pos = new PVector(1200,40);
    
    reds = new int[256];
    greens = new int[256];
    blues = new int[256];
  }
  
  public void update(PImage buffer) {
    reds = new int[256];
    greens = new int[256];
    blues = new int[256];
    
    for (int i = 0; i < buffer.pixels.length; i++) {
      int c = buffer.pixels[i];
      reds[(int) red(c)]++;
      greens[(int) green(c)]++;
      blues[(int) blue(c)]++;
    }
    
    //this.max = 0;
    //int maxIndex = -1;
    //String maxColor = "z";  
    //for (int i = 0; i < 256; i++) {
    //  if (blues[i] > this.max) {
    //    this.max = blues[i];
    //    maxIndex = i;
    //    maxColor = "blue"; 
    //  }
    //  if (reds[i] > this.max) {
    //    this.max = reds[i];
    //    maxIndex = i;     
    //    maxColor = "red";
    //  }
    //  if (greens[i] > this.max) {
    //    this.max = greens[i];
    //    maxIndex = i;
    //    maxColor = "green";
    //  }
    //}
    
    this.max = (int) graphSlider.currVal;
    
    //max = 0;
    //for (int i = 0; i < 256; i++) {
    //  if (reds[i] > max) max = reds[i];
    //}
    //for (int i = 0; i < 256; i++) {
    //  if (greens[i] > max) max = greens[i];
    //}
    //for (int i = 0; i < 256; i++) {
    //  if (blues[i] > max) max = blues[i];
    //}

    //println("max index: " + maxColor + ": " + maxIndex);
    //println("r:   " + reds[20]);
    
    
  }

  public void draw() {
    //bg
    fill(bg);
    noStroke();
    stroke(40);
    int padding = 40;
    rect(this.pos.x - padding / 2, this.pos.y - padding, this.size.x + padding, this.size.y + 1.7f*padding);

    
    //grid
    int rows = 6;
    int cols = 8;
    float rowSize = this.size.y / rows;
    float colSize = this.size.x / cols;
    fill(80);
    stroke(150);
    
    pushMatrix();
    translate(this.pos.x, this.pos.y);
    for (int i = 0; i <= rows; i++) {
      for (int j = 0; j <= cols; j++) {
        line(j * colSize, i * rowSize, j * colSize, this.size.y);
        line(j * colSize, i * rowSize, this.size.x, i * rowSize);
      }
    }
    popMatrix();
    
    //color dots
    pushMatrix();
    translate(this.pos.x, this.pos.y + this.size.y);
    scale(1,-1);
    PVector sc = new PVector( size.x / 256, size.y / this.max);
    ellipseMode(CENTER);
    noStroke();
    int sz = 3;
    for (int i = 0; i < 256; i++) {
      noStroke();
      fill(255, 0, 0);
      ellipse(i * sc.x, reds[i] * sc.y, sz, sz);
      fill(0, 255, 0);
      ellipse(i * sc.x, greens[i] * sc.y, sz, sz);
      fill(0, 0, 255);
      ellipse(i * sc.x, blues[i] * sc.y, sz, sz);
      
      //if dots overlapping, draw gray
      if (reds[i] == greens[i] && greens[i] == blues[i]) {
        noStroke();
        fill(80, 80, 80);
        ellipse(i * sc.x, reds[i] * sc.y, sz, sz);
      }
      
      if (i == 255) continue;
      //lines connecting dots
      strokeWeight(2);
      stroke(255, 0, 0);
      line(i * sc.x, reds[i] * sc.y, (i+1) * sc.x, reds[i+1] * sc.y);
      stroke(0, 255, 0);
      line(i * sc.x, greens[i] * sc.y, (i+1) * sc.x, greens[i+1] * sc.y);
      stroke(0, 0, 255);
      line(i * sc.x, blues[i] * sc.y, (i+1) * sc.x, blues[i+1] * sc.y);
      
      //if lines overlapping draw gray
      if ((reds[i] == greens[i] && greens[i] == blues[i]) || (reds[i] > graphSlider.rangeVal.y && greens[i] > graphSlider.rangeVal.y && blues[i] > graphSlider.rangeVal.y)) {
        stroke(80, 80, 80);
        line(i * sc.x, reds[i] * sc.y, (i+1) * sc.x, reds[i+1] * sc.y);
      }
    }
    
    noStroke();
    
    popMatrix();
    
    //label 'Color Graph'
    fill(90);
    textAlign(CENTER);
    textSize(textSize / 1.1f);
    text("Color Graph", (this.pos.x + this.pos.x + this.size.x) / 2, this.pos.y - 12);
    textSize(textSize);
    textAlign(LEFT);
  }
}
PImage buffer = createImage(10, 10, RGB);
PImage readBuffer = buffer.copy();
PImage paddedBuffer;
int currentIndex = 0;
boolean working = false;
List<String> jobs = new ArrayList<>();
List<float[]> params = new ArrayList<>();
//milli
float timeLimit = 50;
float pt = System.nanoTime() * NANO_TO_MILLI;

public void request(String filter, float... params_) {
  filter = filter.toLowerCase();
  //add or update current jobs
  if (jobs.contains(filter)) {
    //if its current filter, reset index and do again
    if (jobs.indexOf(filter) == 0) {
      currentIndex = 0;  
    }
    jobs.set(jobs.indexOf(filter), filter);
    params.set(jobs.indexOf(filter), params_);
  } else {
    jobs.add(filter);
    params.add(params_);
  }
}

public void setBuffer(PImage readImage) {
  buffer = readImage.copy();
  readBuffer = buffer.copy();
}

public void updateEditor() {
  if (jobs.size() <= 0) {
    working = false;
    return;
  }
  
  working = true;
  
  switch (jobs.get(0)) {
    case "brighten":
      buffer = brighten(params.get(0)[0]);
      break;
    case "blur":
      buffer = blur(params.get(0)[0]);
      break;
    case "threshold":
      buffer = threshold(params.get(0)[0]);
      break;
    case "bloom":
      buffer = bloom(params.get(0)[0]);
      break;
    case "invert":
      buffer = invert();
      break;
    case "mirror x-axis":
      buffer = mirrorX();
      break;
    case "mirror y-axis":
      buffer = mirrorY();
      break;
    case "threshold color":
      buffer = thresholdColor(params.get(0)[0]);
      break;
    case "padding":
      buffer = padding(round(params.get(0)[0]));
      break;
    case "grayscale":
      buffer = grayscale();
      break;
    case "remove red":
      buffer = removeColor("red");
      break;
    case "remove green":
      buffer = removeColor("green");
      break;
    case "remove blue":
      buffer = removeColor("blue");
      break;
    case "saturate":
      buffer = saturate(params.get(0)[0]);
      break;
    case "contrast":
      buffer = contrast(params.get(0)[0]);
  }
  
  //finish job
  if (currentIndex >= buffer.pixels.length - 1) {
    finishJob();
    updateEditor();
  }
}

public void finishJob() {
  currentIndex = 0;
  jobs.remove(0);
  params.remove(0);
  readBuffer = buffer.copy();
}

public PImage mirrorY() {
  PImage writeImage = createImage(buffer.width, buffer.height, RGB);
  
  pt = System.nanoTime() * NANO_TO_MILLI;
  
  for (; currentIndex < buffer.pixels.length; currentIndex++) {
    int i = currentIndex;
    int r = i / writeImage.width;
    int col = i % writeImage.width;
    col = -abs(col - (readBuffer.width / 2)) + (readBuffer.width / 2);
    int index = (r * readBuffer.width) + col;
    int c = readBuffer.pixels[index];
    writeImage.pixels[i] = c;
    
    if (pastLimit()) return writeImage;
  }
  
  return writeImage;
}


public PImage testzzz(PImage readImage) {
  if (currentIndex == 0) {
    //currentFilter = "test";
    buffer = readImage.copy();
  }
  working = true;
  PImage writeImage = readImage.copy();
  currentIndex++;
  writeImage.pixels[currentIndex] = color(0, 0, 0);
  if (currentIndex == writeImage.pixels.length - 1) {
    working  = false;
    currentIndex = 0;
  }
  return writeImage;
}

public PImage mirrorX() {
  PImage writeImage = createImage(buffer.width, buffer.height, RGB);
  
  pt = System.nanoTime() * NANO_TO_MILLI;
  
  for (; currentIndex < buffer.pixels.length; currentIndex++) {
    int i = currentIndex;
    int r = i / writeImage.width;
    int col = i % writeImage.width;
    r = -abs(r - (readBuffer.height / 2)) + (readBuffer.height / 2);
    int index = (r * readBuffer.width) + col;
    int c = readBuffer.pixels[index];
    writeImage.pixels[i] = c;
    
    if (pastLimit()) return writeImage;
  }
  
  return writeImage;
}

public PImage invert() {
  PImage writeImage = createImage(buffer.width, buffer.height, RGB);
  
  pt = System.nanoTime() * NANO_TO_MILLI;

  for (; currentIndex < writeImage.pixels.length; currentIndex++) {
    int i = currentIndex;
    int c = readBuffer.pixels[i];
    c = color(255 - red(c), 255 - green(c), 255 - blue(c));
    writeImage.pixels[i] = c;
    
    if (pastLimit()) return writeImage;
  }
  
  return writeImage;
}

public PImage blur(float radius) {
  radius = round(radius);
  PImage writeImage = buffer.copy();
  PImage readBuffer2 = addPadding(readBuffer, (int) radius);
  
  
  pt = System.nanoTime() * NANO_TO_MILLI;
  
  for (; currentIndex < writeImage.pixels.length; currentIndex++) {
    int i = currentIndex;
    int row = i / writeImage.width;
    int col = i % writeImage.width;
    int r = 0, g = 0, b = 0;
    
    for (int j = (int) -radius; j < radius + 1; j++) {
      for (int k = (int) -radius; k < radius + 1; k++) {
        //int index = ((row + j) * writeImage.width) + (col + k);
        int index = paddingTransform(buffer, row + j, col + k, (int) radius);
        int c = readBuffer2.pixels[index];
        
        r += red(c);
        g += green(c);
        b += blue(c);
      }
    }
    
    r /= ((2 * radius) + 1) * ((2 * radius) + 1);
    g /= ((2 * radius) + 1) * ((2 * radius) + 1);
    b /= ((2 * radius) + 1) * ((2 * radius) + 1);
    
    writeImage.pixels[i] = color(r, g, b);
    if (pastLimit()) return writeImage;
  }
  
  return writeImage;
}

public PImage removeColor(String c) {
  PImage writeImage = createImage(readBuffer.width, readBuffer.height, RGB);
  
  pt = System.nanoTime() * NANO_TO_MILLI;
  
  for (; currentIndex < readBuffer.pixels.length; currentIndex++) {
    int i = currentIndex;
    int cc = readBuffer.pixels[i];
    if (c.equals("red")) cc = color(0, green(cc), blue(cc));
    if (c.equals("green")) cc = color(red(cc), 0, blue(cc));
    if (c.equals("blue")) cc = color(red(cc), green(cc), 0);

    writeImage.pixels[i] = cc;
    
    if (pastLimit()) return writeImage;
  }
  
  return writeImage;
}

public PImage grayscale() {
  PImage writeImage = createImage(readBuffer.width, readBuffer.height, RGB);

  pt = System.nanoTime() * NANO_TO_MILLI;

  for (; currentIndex < writeImage.pixels.length; currentIndex++) {
    int i = currentIndex;
    int c = readBuffer.pixels[i];
    int cc = color((red(c) + green(c) + blue(c)) / 3);
    writeImage.pixels[i] = cc;
    
    if (pastLimit()) return writeImage;
  }
  
  return writeImage;
}

public int blurPixel(PImage img, int i, float radius) {
  radius = round(radius);
  //PImage paddedImg = createImage(img.width + ((int) radius * 2), img.height + ((int) radius * 2), RGB);
  int row = i / img.width;
  int col = i % img.width;
  int r = 0, g = 0, b = 0;
  
  for (int j = (int) -radius; j < radius + 1; j++) {
    for (int k = (int) -radius; k < radius + 1; k++) {
      int index = paddingTransform(img, row - j, col - k, (int) radius);
      int c = paddedBuffer.pixels[index];
      
      r += red(c);
      g += green(c);
      b += blue(c);
    }
  }
  
  r /= ((2 * radius) + 1) * ((2 * radius) + 1);
  g /= ((2 * radius) + 1) * ((2 * radius) + 1);
  b /= ((2 * radius) + 1) * ((2 * radius) + 1);
  
  return color(r, g, b);
}

public PImage bloom(float amt) {
  if (currentIndex == 0) paddedBuffer = addPadding(buffer, (int) round(amt));
  
  PImage writeImage = buffer.copy();
  
  pt = System.nanoTime() * NANO_TO_MILLI;
    
  for (; currentIndex < buffer.pixels.length; currentIndex++) {
    int i = currentIndex;
    
    int blurred = blurPixel(readBuffer, i, amt);
    if (brightness(blurred) == 0) {
      writeImage.pixels[i] = readBuffer.pixels[i];
    } else {
      //blur/bloom
      writeImage.pixels[i] = (total(readBuffer.pixels[i]) > total(blurred)) ? readBuffer.pixels[i] : blurred;
    }
    
    if (pastLimit()) return writeImage;
  }
  
  return writeImage;
}

public PImage threshold(float lim) {
  PImage writeImage = buffer.copy();
  
  pt = System.nanoTime() * NANO_TO_MILLI;
  
  for (; currentIndex < buffer.pixels.length; currentIndex++) {
    int i = currentIndex;
    int c = readBuffer.pixels[i];
    writeImage.pixels[i] = ((red(c) + green(c) + blue(c)) / 3 > lim) ? readBuffer.pixels[i] : color(0, 0, 0);
    if (pastLimit()) return writeImage;  
  }
  
  return writeImage;
}

public PImage thresholdColor(float lim) {
  PImage writeImage = buffer.copy();
  
  pt = System.nanoTime() * NANO_TO_MILLI;
  
  for (; currentIndex < buffer.pixels.length; currentIndex++) {
    int i = currentIndex;
    int c = readBuffer.pixels[i];
    float r = (red(c) > lim ? red(c) : 0);
    float g = (green(c) > lim ? green(c) : 0);
    float b = (blue(c) > lim ? blue(c) : 0);
    writeImage.pixels[i] = color(r, g, b);
    if (pastLimit()) return writeImage;
  }
  
  return writeImage;
}

public PImage contrast(float strength) {
  println(strength);
  float lim = 200;
  PImage writeImage = buffer.copy();
  pt = System.nanoTime() * NANO_TO_MILLI;
  
  for (; currentIndex < buffer.pixels.length; currentIndex++) {
    int br = total(readBuffer.pixels[currentIndex]);
    int addition = (int) ((strength * 0.3f) * (br - lim));
    if (addition < 0) addition *= 6;
    writeImage.pixels[currentIndex] = brighten(readBuffer.pixels[currentIndex], addition);
  }
  
  return writeImage;
}

public boolean pastLimit() {
  return (System.nanoTime() * NANO_TO_MILLI) - pt >= timeLimit;
}

public PImage brighten(float amt) {
  PImage writeImage = buffer.copy();
  pt = System.nanoTime() * NANO_TO_MILLI;
  
  for (; currentIndex < buffer.pixels.length; currentIndex++) {
    writeImage.pixels[currentIndex] = brighten(buffer.pixels[currentIndex], amt);
    if (pastLimit()) return writeImage;
  }
  
  return writeImage;
}

//PImage saturate1(PImage readImage, int amt) {
//  PImage writeImage = createImage(readImage.width, readImage.height, RGB);
//  for (int i = 0; i < readImage.pixels.length; i++) {
//    color c = readImage.pixels[i];
//    float r = red(c);
//    float g = green(c);
//    float b = blue(c);
//    float max = max(r, g, b);
//    color nc = c;
//    int subAmt = (int) ((total(c) / 3 > 240) ? 0 : -amt * 0.5);
//    if (red(c) == max) nc = add(c, amt, subAmt, subAmt);
//    if (green(c) == max) nc = add(c, subAmt, amt, subAmt);
//    if (blue(c) == max) nc = add(c, subAmt, subAmt, amt);
//    if (total(c) / 3 == red(c)) nc = c;
        
//    writeImage.pixels[i] = nc;
//  }

//  return writeImage;
//}

public PImage saturate(float amt) {
  PImage writeImage = buffer.copy();
  pt = System.nanoTime() * NANO_TO_MILLI;

  for (; currentIndex < readBuffer.pixels.length; currentIndex++) {
    int i = currentIndex;
    int c = readBuffer.pixels[i];
    float r = red(c);
    float g = green(c);
    float b = blue(c);
    float avg = total(c) / 3;
    float amt2 = amt;
    float diff = maxChannel(c) - minChannel(c);
    amt2 = Math.min(1, 0.03f*diff) * amt;

    
    //float r2 = r + ((r - avg >= 0) ? amt2 : -amt2);    
    //float g2 = g + ((g - avg >= 0) ? amt2 : -amt2);    
    //float b2 = b + ((b - avg >= 0) ? amt2 : -amt2);
    
    float rFactor = 0.1f * (r - avg);
    rFactor = Math.max(0, Math.min(1, rFactor));
    
    float gFactor = 0.1f * (g - avg);
    gFactor = Math.max(0, Math.min(1, gFactor));

    float bFactor = 0.1f * (b - avg);
    bFactor = Math.max(0, Math.min(1, bFactor));

    float r2 = r + (rFactor * amt2);
    float g2 = g + (gFactor * amt2);
    float b2 = b + (bFactor * amt2);

    writeImage.pixels[i] = color((int) r2, (int) g2, (int) b2);
    if (pastLimit()) return writeImage;
  }

  return writeImage;
}

public PImage saturate2(float amt) {
  pt = System.nanoTime() * NANO_TO_MILLI;
  amt = (int) amt;
  
  PImage writeImage = createImage(buffer.width,  buffer.height, RGB);
  for (; currentIndex < readBuffer.pixels.length; currentIndex++) {
    int i = currentIndex;
    int c = readBuffer.pixels[i];
    float min = minChannel(c);
    int nc = c;
    if (red(c) == min) nc = add(c, -amt, 0, 0);
    if (green(c) == min) nc = add(c, 0, -amt, 0);
    if (blue(c) == min) nc = add(c, 0, 0, -amt);
    if (maxChannel(c) - minChannel(c) < 10) nc = c;
        
    writeImage.pixels[i] = nc;
    if (pastLimit()) return writeImage;
  }

  return writeImage;
}

public int total(int c) {
  return (int) (red(c) + green(c) + blue(c));
}

public int darken(int c, int v) {
  return color(red(c) - v, green(c) - v, blue(c) - v);
}

public int darken(int c) {
  return color(red(c) - 20, green(c) - 20, blue(c) - 20);
}

public int brighten(int c) {
  return color(red(c) + 20, green(c) + 20, blue(c) + 20);
}

public int brighten(int c, float v) {
  return color(red(c) + v, green(c) + v, blue(c) + v);
}

public int add(int c1, int c2) {
  return color(red(c1) + red(c2), green(c1) + green(c2), blue(c1) + blue(c2));
} 

public int add(int c1, float... a) {
  return color(red(c1) + a[0], green(c1) + a[1], blue(c1) + a[2]);
}

public float maxChannel(int c) {
  return max(red(c), blue(c), green(c));
}

public float minChannel(int c) {
  return min(red(c), blue(c), green(c));
}

public PImage addPadding(PImage readImage, int padding) {
  PImage newImg = createImage(readImage.width + (padding * 2), readImage.height + (padding * 2), RGB);
  int avgColor = getAvg(readImage);
  
  for (int i = 0; i < newImg.pixels.length; i++) {
    int row = i / newImg.width;
    int col = i % newImg.width;
    if ((row > padding - 1 && row < newImg.height - padding) && (col > padding - 1 && col < newImg.width - padding)) {
      int i2 = inversePaddingTransform(readBuffer, i, padding);
      newImg.pixels[i] = readImage.pixels[i2];
    } else {
      newImg.pixels[i] = avgColor;
    }
    
  } 
  
  return newImg;
}

public PImage padding(int padding) {
  PImage newImg = createImage(buffer.width + (padding * 2), buffer.height + (padding * 2), RGB);

  for (; currentIndex < newImg.pixels.length; currentIndex++) {
    int i = currentIndex;
    int row = i / newImg.width;
    int col = i % newImg.width;
    if ((row > padding - 1 && row < newImg.height - padding) && (col > padding - 1 && col < newImg.width - padding)) {
      int i2 = inversePaddingTransform(readBuffer, i, padding);
      newImg.pixels[i] = readBuffer.pixels[i2];
    } else {
      newImg.pixels[i] = color(0, 0, 0);
    } 
  } 
  
  return newImg;
}

public int inversePaddingTransform(PImage originalImg, int index, int padding) {
  int row = index / (originalImg.width + (padding * 2));
  int col = index % (originalImg.width + (padding * 2));
  return ((row - padding) * originalImg.width) + (col - padding);
}

public int paddingTransform(PImage originalImg, int index, int padding) {
  int row = index / originalImg.width;
  int col = index % originalImg.width;
  return ((row + padding) * (originalImg.width + (2 * padding))) + (col + padding);
}

public int paddingTransform(PImage originalImg, int row, int col, int padding) {
  return ((row + padding) * (originalImg.width + (2 * padding))) + (col + padding);
}

public int getAvg(PImage img) {
  int r = 0;
  int g = 0;
  int b = 0;
  
  for (int i = 0; i < img.pixels.length; i++) {
    int c = img.pixels[i];
    r += red(c);
    g += green(c);
    b += blue(c);
  }
  int size = img.width * img.height;
  return color(round(r / size), round(g / size), round(b / size));
}
public PVector worldToScreen(PVector worldPos, PVector offset, PVector scale) {
    float x = (worldPos.x - offset.x) * scale.x;
    float y = (worldPos.y - offset.y) * scale.y;
    return new PVector(x,y);
}

public PVector worldToScreen(PVector worldPos, PVector offset, float scale) {
    float x = (worldPos.x - offset.x) * scale;
    float y = (worldPos.y - offset.y) * scale;
    return new PVector(x,y);
}

public PVector screenToWorld(PVector screenPos, PVector offset, PVector scale) {
    float x = (screenPos.x / scale.x) + offset.x;
    float y = (screenPos.y / scale.y) + offset.y;
    return new PVector(x,y);
}

public PVector screenToWorld(PVector screenPos, PVector offset, float scale) {
    float x = (screenPos.x / scale) + offset.x;
    float y = (screenPos.y / scale) + offset.y;
    return new PVector(x,y);
}


public PVector worldToScreen(PVector worldSize, PVector scale) {
    float w = worldSize.x * scale.x;
    float h = worldSize.y * scale.y;
    return new PVector(w, h);
}

public float worldToScreen(float worldSize, float scale) {
    return worldSize * scale;
}


public PVector screenToWorld(PVector screenSize, PVector scale) {
    float w = screenSize.x / scale.x;
    float h = screenSize.y / scale.y;
    return new PVector(w, h);
}

public float screenToWorld(float screenSize, float scale) {
    return screenSize / scale;
}

public void textStroke(String text, float x, float y) {
  fill(0);
  for(int i = -1; i <= 1; i++){
    text(text, x+i,y);
    text(text, x,y+i);
  }
  
  fill(255);
  
  text(text, x, y);
}

public void textStroke(String text, float x, float y, int thickness) {
  fill(0);
  for(int i = -thickness; i <= thickness; i++){
    text(text, x+i,y);
    text(text, x,y+i);
  }
  
  fill(255);
  
  text(text, x, y);
}

public void textStroke(String text, float x, float y, int thickness, float alpha) {
  fill(0, alpha);
  for(int i = -thickness; i <= thickness; i++){
    text(text, x+i,y);
    text(text, x,y+i);
  }
  
  fill(255, alpha);
  
  text(text, x, y);
}

public void textStroke(String text, float x, float y, int thickness, int textSize, float alpha) {
  fill(0, alpha);
  textSize(textSize);
  for(int i = -thickness; i <= thickness; i++){
    text(text, x+i,y);
    text(text, x,y+i);
  }
  
  fill(255, alpha);
  
  text(text, x, y);
}

public boolean mouseIn(PVector TL, PVector size) {
  return mouseX > TL.x && mouseX < TL.x + size.x && mouseY > TL.y && mouseY < TL.y + size.y;
}

public boolean pointInsideRect(PVector point, PVector pos, PVector size) {
  return (point.x > pos.x && point.x < pos.x + size.x) && (point.y > pos.y && point.y < pos.y + size.y);
}



public List<String> readFile(String dir) {
  List<String> o = new ArrayList<>();
  BufferedReader reader = createReader(dir);
  String line = null;
  try {
    while ((line = reader.readLine()) != null) {
      if (line.startsWith("//")) continue;
      o.add(line);
    }
    reader.close();
  } catch (IOException e) {
    e.printStackTrace();
  }
  
  return o;
}
class Slider extends UIElement {
  PVector rangeScreen, rangeVal, currPos;
  float pVal, currVal;
  boolean dragging, hovering;
  
  public Slider(PVector pos, PVector size, PVector range) {
    super(pos, size, loadImage("data\\ui\\slider_1_1.png"), loadImage("data\\ui\\slider_1_2.png"));
    sprites.get(1).resize((int) size.x, sprites.get(1).height);
    sprites.get(0).resize(0, (int) size.y);

    this.rangeScreen = new PVector(pos.x, pos.x + size.x);
    this.rangeVal = range;
    this.currPos = pos.copy();
  }
  
  public void update() {
    //drag
    if (!pmousePressed && mousePressed && pointInsideRect(mousePos, pos, size)) {
      dragging = true;
    }
    if (!mousePressed) dragging = false;
    if (dragging) {
      currPos.set(mousePos.x, currPos.y);
    }
    
    updated = false;
    if (pVal != currVal) updated = true;
    
    if (currPos.x < rangeScreen.x) currPos.set(rangeScreen.x, currPos.y);
    if (currPos.x > rangeScreen.y) currPos.set(rangeScreen.y, currPos.y);
    if (currPos.y != pos.y) currPos.set(currPos.x, pos.y);
    
    //value
    pVal = currVal;
    currVal = ((currPos.x - rangeScreen.x) / (rangeScreen.y - rangeScreen.x)) * (rangeVal.y - rangeVal.x) + rangeVal.x;
  }
  
  public void draw() {
    super.draw();

    image(sprites.get(1), pos.x, pos.y + (size.y / 2) - (sprites.get(1).height / 2));
    imageMode(CENTER);
    image(sprites.get(0), currPos.x, currPos.y + (sprites.get(0).height / 2));
    
    //image(sprites.get(0), 0, 0);
    imageMode(CORNER);  
  }
  
  public void set(float val) {
    currPos = new PVector((val - rangeVal.x) / (rangeVal.y - rangeVal.x) * (rangeScreen.y - rangeScreen.x) + pos.x, currPos.y);
  }
  
  //gets proportion
  public float getProp() {
    return (currPos.x - rangeScreen.x) / (rangeScreen.y - rangeScreen.x);
  }
}


public class UIElement {
  PVector pos, size;
  List<PImage> sprites;
  boolean updated;
  
  public UIElement(PVector pos, PVector size, PImage... sprites) {
    this.pos = pos;
    this.size = size;
    this.sprites = Arrays.asList(sprites);
  }
  
  public void update() {}
  public void draw() {
    if (drawWireFrames) {
      noFill();
      strokeWeight(2);
      stroke(50, 50, 250);
      rect(pos.x, pos.y, size.x, size.y);
    }
  }
}


class UIGrid {
  PVector pos, size;
  int rows, cols;
  List<UIElement> elements;
  //(row, column)
  List<PVector> positions;
  List<Boolean> centered;
  
  public UIGrid(PVector pos, PVector size, int rows, int cols) {
    this.pos = pos;
    this.size = size;
    this.elements = new ArrayList<>();
    this.positions = new ArrayList<>();
    this.centered = new ArrayList<>();
    this.rows = rows;
    this.cols = cols;
  }
  
  public void add(UIElement element, int row, int col, boolean centered_) {
    if (!centered_) {
      element.pos = new PVector(pos.x + (col * (size.x / cols)), pos.y + (row * (size.y / rows)));
    } else {
      element.pos = new PVector(pos.x + (col * (size.x / cols)), pos.y + (row * (size.y / rows)) + ((size.y / rows) / 2) - (element.size.y / 2));
    }
    
    elements.add(element);
    positions.add(new PVector(row, col));
    centered.add(centered_);
  }
  
  public void remove(int row, int column) {
    int index = toIndex(row, column);
    
    positions.remove(index);
    elements.remove(index);
    centered.remove(index);
  }
  
  public int toIndex(int row, int column) {
    return (int) (row * cols) + column;
  }
  
  public void update() {
    for (UIElement e : elements) {
      e.update();
    }
  }
  
  public void draw() {
    if (drawWireFrames) {
      for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
          strokeWeight(2);
          stroke(250, 50, 50);
          noFill();
          rect(pos.x + (j * (size.x / cols)), pos.y + (i * (size.y / rows)), size.x / cols, size.y / rows);
        }
      }
    }
    
    for (UIElement e : elements) {
      e.draw();
    }
  }
  
  public PVector posAt(int row, int col) {
    return new PVector(pos.x + (col * (size.x / cols)), pos.y + (row * (size.y / rows)));
  }
  
  public UIElement getElement(int row, int col) {
    for (int i = 0; i < elements.size(); i++) {
      if (positions.get(i).x == row && positions.get(i).y == col) {
        return elements.get(i);
      }
    }
    
    return new UIElement(new PVector(), new PVector());
  }
}


  public void settings() { size(1920, 1080);
pixelDensity(1);
noSmooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ImageEdit_2" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
